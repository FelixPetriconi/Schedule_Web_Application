{
    "presenters": [
        {
            "first_name": "Niall",
            "id": 3,
            "last_name": "Douglas",
            "bio": "Just this guy."
        },
        {
            "first_name": "Louis",
            "id": 4,
            "last_name": "Dionne",
            "bio": "Someone you might want to listen to."
        }
    ],
    "scheduled_proposals": [
        {
            "day": "day_4",
            "id": 4,
            "presenters": [3],
            "room": "empire",
            "session": "session_1",
            "text": "Are you using enums to return error states from functions (or even an int or bool!)? Do you find writing exception safe C++ a poor return on coding investment, and end up avoiding using most of the STL entirely because it could throw exceptions in all sorts of unhelpful places? Have you ever wondered what on earth the C++ 11\u2019s <system_error> header is actually useful for?\n\nOne might think that after thirty years C++ would have decided upon a canonical way of handling errors, but it is very clear the jury remains out with heavy fragmentation in the C++ user base as to how best to handle errors. The new systems programming languages Rust and Swift have chosen a canonical error handling system based on immediate stack unwinding returns of integer error codes in a monadic wrapper e.g. Rust\u2019s Result<T> and Option<T>. Efforts are underway to standardise something similar for C++ with optional<T> and soon WG21 LEWG\u2019s expected<T, E> which recently lost its monadic operations as it gets pared ever further down to its essentials for standardisation.\n\nThis talk reviews these four standardised error handling techniques in C++, and how well the three major compilers and library implementations implement these techniques into overhead. I will also be introducing for the first time my own solution to this problem called _outcomes_ (implemented by a proposed Boost.Outcome library) which implement a very impure and dirty - but very lightweight on compile and runtime overhead - simple \u201cmongrel monad\u201d outcome<T>, result<T> and option<T> transport factory specifically targeted at extending C++ 11\u2019s std::exception_ptr and std::error_code in a more convenient to use form, thus providing a unified lossless error handling system for C++. I am hoping these will eventually form part of SG14 (games/low latency)\u2019s recommendations for maximum performance C++ as a lighter weight and more convenient to use for error handling alternative to the LEWG expected<T, E>.\n\n\nTimeplan\n20 mins: Explanation of these C++ 11 methods of error handling: C error code, exception throws, std::error_code &ec.\n20 mins: Explanation of optional<T> and expected<T, E> as a means of error handling.\n20 mins: Explanation of outcome::basic_monad<T, EC, E> and how it differs from expected<T, E>\n20 mins: Many pretty graphs comparing time and space overheads.\n10 mins: Questions.\n",
            "title": "Mongrel Monads, Dirty, Dirty, Dirty"
        },
        {
            "day": "day_1",
            "id": 5,
            "presenters": [4],
            "room": "bristol_2",
            "session": "session_3",
            "text": "In most languages, metaprogramming is a powerful tool that allows writing more expressive and more maintainable code. It is usually relatively straightforward, and even average Joe programmers can use it to increase their productivity. In C++, metaprogramming is an obscure art that very few understand and that is never taught as part of the normal curriculum. Even worse is the fact that almost every presentation about metaprogramming is overly complicated, using tricky corners of the language and an unintuitive approach to achieve even simple goals. This presentation will try to break the mold and present metaprogramming in a way that's easy to grasp. Using C++14 and the Boost.Hana library, we will show how metaprogramming can be done with a reasonably high level of expressiveness, leaving dirty template tricks far behind. We will see how metaprogramming can be used as a tool for making day-to-day programming easier, more enjoyable and more efficient, even for people that are not C++ gurus.",
            "title": "Metaprogramming in C++14"
        }
    ]
}
